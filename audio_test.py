# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'audio_test.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from sqlite3 import connect
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QFileDialog
from cgi import test
from statistics import mean
from audio_test_bench.AudioAnalyzer.audio_analyzer import AudioAnalyzer
from spark_cli import SparkCLI
from data_recorder import DataWriterSQLite
from data_recorder import DataReaderSQLite
import sounddevice as sd
from scipy.io.wavfile import write
from scipy.io.wavfile import read
import matplotlib.pyplot as plt
import matplotlib
from matplotlib import interactive
matplotlib.use('Qt5Agg')
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas, NavigationToolbar2QT as NavigationToolbar
from matplotlib.figure import Figure
from datetime import datetime
import os
import time
import sys
from datetime import datetime
from spark_cli.spark_cli_app import SparkCliApp
from audio_test_ui import Ui_MainWindow
import numpy as np
import mplcursors

# Add AudioAnalyzer/src to PYTHONPATH
lib_path = os.path.abspath(os.path.join('../audio_test_bench', 'AudioAnalyzer'))
sys.path.append(lib_path)
import audio_analyzer as analyzer


class MplCanvas(FigureCanvas):

    def __init__(self, parent=None, width=5, height=4, dpi=100):
        fig = Figure(figsize=(width, height), dpi=dpi)
        self.axes_array = []
        #self.axes  = fig.add_subplot(311)
        #self.axes1 = fig.add_subplot(312)
        #self.axes2 = fig.add_subplot(313)
        fig.set_tight_layout(True)
        self.size = fig.get_size_inches()
        self.dpi = dpi
        self.figure = fig
        super(MplCanvas, self).__init__(self.figure)

    def reload_figure(self, subplot_num) :
        self.axes_array = []
        self.figure.clear(True)
        for i in range(subplot_num):
            self.axes_array.append(self.figure.add_subplot(subplot_num,1, i + 1))
        self.figure.set_tight_layout(True)
        self.size = self.figure.get_size_inches()

class Main(QtWidgets.QMainWindow, Ui_MainWindow):
    working_dir = 0
    working_test_path = 0
    analyzer_rec = AudioAnalyzer()
    record = {}
    board1_available_stats = {}
    board2_available_stats = {}
    db_glitch_start = []
    db_glitch_end = []
    elapse_time_ms = 0
    g1_title = "first"
    g2_title = "second"
    g3_title = "third"
    audioB1 = 0
    audioB2 = 0
    writer_instance = 0
    writer_instanceB2 = 0
    recording_name = 0
    absolute_start_time = 0
    def __init__(self):
        QtWidgets.QMainWindow.__init__(self)
        self.setupUi(self)
        self.sc = MplCanvas(self, width=5, height=4, dpi=100)
        self.x1 = []
        self.x2 = []
        self.x3 = []
        self.y1 = dict()
        self.y1['data'] = []
        self.y1['name'] = []
        self.y2 = dict()
        self.y2['data'] = []
        self.y2['name'] = []
        self.y3 = []
        # Create toolbar, passing canvas as first parament, parent (self, the MainWindow) as second.
        toolbar = NavigationToolbar(self.sc, self)
        layoutToolbar = QtWidgets.QVBoxLayout()
        layoutToolbar.addWidget(toolbar)

        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(self.sc)

        # Create a placeholder widget to hold our toolbar and canvas.
        self.plot_wid.setLayout(layoutToolbar)
        #self.scrollAreaWidgetContents.setSizePolicy(QtWidgets.QSizePolicy.Fixed,QtWidgets.QSizePolicy.Fixed)
        self.scrollAreaWidgetContents.resize(1400,400)
        self.scrollAreaWidgetContents.setLayout(layout)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.show()
        self._update_plot()

        self.select_folder_pb.clicked.connect(self.select_folder)
        self.analyze_pb.clicked.connect(self.analyze_audio)
        self.load_db_pb.clicked.connect(self.load_board_db_field)
        self.test_pb.clicked.connect(self.plot_data)
        self.Connect_pb.clicked.connect(self.connect_to_board)
        self.start_test_pb.clicked.connect(self.start_test)
        self.test_dur_le.setText('15')
        self.analyze_slider.valueChanged.connect(self.slider_update)
        self.analyze_slider.setValue(5)
        self.clear_all_b1_pb.clicked.connect(self.clear_all_b1)
        self.clear_all_b2_pb.clicked.connect(self.clear_all_b2)

    def select_folder (self):
        dialog = QFileDialog(self)
        working_dir = dialog.getOpenFileName(self, 'Choose audio.wav file', os.getcwd())
        self.working_dir = working_dir[0].replace("audio.wav", "")
        self.load_lb.setText("Folder properly loaded !")

    def analyze_audio(self):
        self.record = self.analyzer_rec.read_audio_file(self.working_dir + 'audio.wav')
        self.analyzer_rec.analyze_audio(self.record, self.analyze_slider.value())
        self.load_lb.setText("Analysis finished, starting glitch extraction")
        # TODO only one elapse time, could get one for both board
        elapse_time = self._load_b1_db().read('audioB1', 'elapsed_time_ms')
        time_idx = 0
        test_margin = 1 # 1second
        glitch_started = False
        glitch_details = []
        for i in range(len(self.record['glitch left']['start'])):
            glitch_start_time = self.record['glitch left']['start'][i] - test_margin
            glitch_end = self.record['glitch left']['end'][i] + test_margin
            for i in range(len(elapse_time) - 1):
                if elapse_time[i]/1000 >= glitch_start_time and not glitch_started:
                    self.db_glitch_start.append(i)
                    glitch_started = True
                elif elapse_time[i]/1000 >= glitch_end and glitch_started:
                    self.db_glitch_end.append(i)
                    glitch_started = False
                    glitch_details.append(str(glitch_end - glitch_start_time))
                    break
        self.glitch_cb.clear()
        self.glitch_cb.addItems(glitch_details)
        self.glitch_cb.setCurrentIndex(0)
        self.elapse_time_ms = elapse_time
        self.g1_title = "sinad"
        self._clear_axis()
        self.x1 = list(range(0, len(self.record['sinad left'])))
        self.y1['name'].append('sinad left')
        self.y1['data'].append(self.record['sinad left'])
        self._update_plot()

    def load_board_db_field(self):
        # Clear list widget of previously loaded DB
        while self.b1_stats_lw.count() > 0 :
            self.b1_stats_lw.takeItem(0)

        while self.b2_stats_lw.count() > 0 :
            self.b2_stats_lw.takeItem(0)

        self.board1_available_stats = self._load_b1_db().description()
        self.board2_available_stats = self._load_b2_db().description()
        for i in range(len(self.board1_available_stats['audioB1'])):
           item = QtWidgets.QListWidgetItem()
           item.setText(self.board1_available_stats['audioB1'][i])
           item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
           item.setCheckState(QtCore.Qt.Unchecked)
           self.b1_stats_lw.addItem(item)
        for i in range(len(self.board2_available_stats['audioB2'])):
           item = QtWidgets.QListWidgetItem()
           item.setText(self.board2_available_stats['audioB2'][i])
           item.setFlags(item.flags() | QtCore.Qt.ItemIsUserCheckable)
           item.setCheckState(QtCore.Qt.Unchecked)
           self.b2_stats_lw.addItem(item)

    def plot_data(self):
        glitch_windows_start = 0
        glitch_windows_stop  = 0
        input_data = read(self.working_dir + '/audio.wav')
        audio = input_data[1]
        custom_window_started = False
        bypass_glitch_window  = False
        if self.show_bet_cb.isChecked():
            #bypass glitch windows
            if self.show_from_le.text() != "" and self.show_to_le.text() != "":
                bypass_glitch_window = True
                for i in range(len(self.elapse_time_ms) - 1):
                    if self.elapse_time_ms[i]/1000 >= int(self.show_from_le.text()) and not custom_window_started:
                        glitch_windows_start = i
                        custom_window_started = True
                    elif self.elapse_time_ms[i]/1000 >= int(self.show_to_le.text()) and custom_window_started:
                        glitch_windows_stop = i
                        custom_window_started = False
                        break
        else:
            glitch_windows_start = self.db_glitch_start[self.glitch_cb.currentIndex()]
            glitch_windows_stop  = self.db_glitch_end[self.glitch_cb.currentIndex()]
        self.g1_title = 'TX board'
        self.g2_title = 'RX board'
        self.g3_title = "Audio glitch"
        self._clear_axis()
        for i in range(self.b1_stats_lw.count()):
            item = self.b1_stats_lw.item(i)
            if item.checkState():
                stats_to_plot_b1 = self._load_b1_db().read('audioB1', self.board1_available_stats['audioB1'][i])
                self.y1['data'].append(stats_to_plot_b1[glitch_windows_start : glitch_windows_stop])
                self.y1['name'].append(self.board1_available_stats['audioB1'][i])
        self.x1 = self.elapse_time_ms[glitch_windows_start : glitch_windows_stop]

        for i in range(self.b2_stats_lw.count()):
            item = self.b2_stats_lw.item(i)
            if item.checkState():
                stats_to_plot_b2 = self._load_b2_db().read('audioB2', self.board2_available_stats['audioB2'][i])
                self.y2['data'].append(stats_to_plot_b2[glitch_windows_start : glitch_windows_stop])
                self.y2['name'].append(self.board2_available_stats['audioB2'][i])
        self.x2 = self.x1

        # Compute audio X axis
        x_axis_audio = []
        if len(self.record['glitch left']['start']) > 0:
            start = int((self.record['glitch left']['start'][self.glitch_cb.currentIndex()]) * 44100)
            end   = int((self.record['glitch left']['end'][self.glitch_cb.currentIndex()]) * 44100)
            for j in range(end - start):
                x_axis_audio.append((int(start/44100) + j * 1/44100) * 1000)

        #if bypass_glitch_window:
        #    start = int(int(self.show_from_le.text()) * 44100)
        #    end = int(int(self.show_to_le.text()) * 44100)
        #    for j in range(end - start):
        #        x_axis_audio.append((int(start/44100) + j * 1/44100) * 1000)

            self.x3 = x_axis_audio
            self.y3 = audio[start : end]
        self._update_plot()

    def connect_to_board(self):
        #duo
        cliB1 = SparkCLI('207D38A35056','../spark-dev/app/demo/common/protocol/src/proto/')
        cliB2 = SparkCLI('207538A35056','../spark-dev/app/demo/common/protocol/src/proto/')
        #evk
        #cliB1 = SparkCLI('205A33A5484E','../spark-dev/app/demo/common/protocol/src/proto/')
        #cliB2 = SparkCLI('2082338E484E','../spark-dev/app/demo/common/protocol/src/proto/')
        cliB1.connect()
        cliB2.connect()
        self.audioB1 = cliB1.launch_audio()
        self.audioB2 = cliB2.launch_audio()
        self.audioB1.set_cfg_file("board1_unidir")
        self.audioB2.set_cfg_file("board2_unidir")
        self.audioB1.start()
        self.audioB2.start()
        self.load_lb.setText("Connected to board")
        time.sleep(1)
        self.audioB1.wps.reset_stats()
        self.audioB2.wps.reset_stats()
        statsB1, wps = self.audioB1.get_stats()
        statsB2, wpsB2 = self.audioB2.get_stats()
        self._build_up_db(statsB1, wps, statsB2, wpsB2)
        self.load_lb.setText("DB build")

    def start_test(self):
        fs = 44100  # Sample rate
        seconds = int(self.test_dur_le.text()) * 60  # Duration of recording
        x = sd.query_devices()
        sd.default.device = 'HD-Audio Generic: ALC1220 Analog (hw:1,0)'
        file = open(str(self.working_test_path) + '/absolute_start.txt', 'w')
        myrecording = sd.rec(int(seconds * fs), samplerate=fs, channels=1)
        self.absolute_start_time = datetime.timestamp(datetime.now())
        file.write(str(self.absolute_start_time))
        file.close()
        self.audioB1.wps.reset_stats()
        self.audioB2.wps.reset_stats()
        self.audioB1.get_stats()
        self.audioB1.get_stats()
        self.audioB2.get_stats()
        self.audioB2.get_stats()
        process_start = 0
        process_dur = 0
        for i in range(seconds * 5):
            if (0.2 - process_dur > 0):
                time.sleep(0.2 - process_dur)
            process_start = datetime.timestamp(datetime.now())
            statsB1, wps = self.audioB1.get_stats()
            statsB2, wpsB2 = self.audioB2.get_stats()
            self._update_db(statsB1, wps, statsB2, wpsB2)
            self.test_progb.setValue(int(((i) / (seconds * 5)) * 100))
            process_dur = datetime.timestamp(datetime.now()) - process_start

        sd.wait()  # Wait until recording is finished
        write(self.recording_name, fs, myrecording)  # Save as WAV file
        self.load_lb.setText("Test finished !!!!!")

    def slider_update(self):
        self.analysis_sens_te.setText(str(self.analyze_slider.value()))

    def clear_all_b1(self):
        for i in range(self.b1_stats_lw.count()):
            self.b1_stats_lw.item(i).setCheckState(QtCore.Qt.Unchecked)

    def clear_all_b2(self):
        for i in range(self.b2_stats_lw.count()):
            self.b2_stats_lw.item(i).setCheckState(QtCore.Qt.Unchecked)

    def _build_up_db(self, statsB1, wpsB1, statsB2, wpsB2):
        # create filename
        table_name   = "audioB1"
        table_nameB2 = "audioB2"
        path         = "test_result"
        os.makedirs(path, exist_ok=True)
        now = datetime.now()
        now_dir = now.strftime("%d-%m-%Y_%H_%M_%S")
        custom_label = self.test_lb.text() + now_dir
        path = os.path.join(path, custom_label)
        os.makedirs(path, exist_ok=True)
        b1_db_name     = path + "/audioB1TX"
        b2_db_name     = path + "/audioB2TX"
        self.recording_name = path + "/audio.wav"
        self.working_test_path = path
        # Create database
        self.writer_instance   = DataWriterSQLite(b1_db_name)
        self.writer_instanceB2 = DataWriterSQLite(b2_db_name)
        # Create table
        statsB1.update(wpsB1)
        statsB2.update(wpsB2)
        self.writer_instance.create_table(table_name, statsB1)
        self.writer_instanceB2.create_table(table_nameB2, statsB2)

    def _update_db(self, statsB1, wpsB1, statsB2, wpsB2):
        table_name   = "audioB1"
        table_nameB2 = "audioB2"
        statsB1.update(wpsB1)
        statsB2.update(wpsB2)
        self.writer_instance.insert(table_name, statsB1)
        self.writer_instanceB2.insert(table_nameB2, statsB2)
    def _load_b1_db(self)   :
        db_name = self.working_dir + "audioB1TX"  # Create database in RAM
        reader_instance = DataReaderSQLite(db_name)
        return reader_instance

    def _load_b2_db(self):
        db_name = self.working_dir + "audioB2TX"  # Create database in RAM
        reader_instance = DataReaderSQLite(db_name)
        return reader_instance

    def _update_plot(self):
        self.sc.reload_figure(len(self.y1['data']) + len(self.y2['data']) + 1)
        self.scrollAreaWidgetContents.resize(1400,400 * (len(self.sc.axes_array)))
        j = 0
        k = 0
        for i in range(len(self.y1['data'])):
            self.sc.axes_array[i].plot(self.x1, self.y1['data'][i], label=self.y1['name'][i])
            #self.sc.axes.plot(self.x1, self.y1['data'][i], label=self.y1['name'][i])
            self.sc.axes_array[i].legend()
            self.sc.axes_array[i].set_title(self.g1_title)
            mplcursors.cursor(self.sc.axes_array[i])
            j = i + 1
            k = j
        for i in range(len(self.y2['data'])):
            self.sc.axes_array[j + i].plot(self.x1, self.y2['data'][i], label=self.y2['name'][i])
            self.sc.axes_array[j + i].legend()
            self.sc.axes_array[j + i].set_title(self.g2_title)
            mplcursors.cursor(self.sc.axes_array[j + i])
            k = i + j + 1

        if len(self.y3) > 0:
            self.sc.axes_array[k].plot(self.x3, self.y3, 'r')
            self.sc.axes_array[k].set_title(self.g3_title)
            mplcursors.cursor(self.sc.axes_array[k])
        # Trigger the canvas to update and redraw.

        self.sc.draw()

    def _clear_axis(self):
        self.x1 = []
        self.x2 = []
        self.x3 = []
        self.y1['data'] = []
        self.y2['data'] = []
        self.y1['name'] = []
        self.y2['name'] = []
        self.y3 = []

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = Main()
    window.show()
    sys.exit(app.exec_())
